# 设计模式

[史上最全设计模式导学目录（完整版）](http://blog.csdn.net/lovelion/article/details/17517213)

## 模式的定义

每个模式都描述了一个在我们的的环境中不断出现的问题，然后描述了该问题解决方案的核心，然后通过这种方式，我们可以无数次地重用那些已有的成功的解决方案，无需再重复相同的工作。

模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。

## 软件模式

软件模式是将模式的一般概念应用于软件开发领域，即软件开发的总体指导思路或参照样板。

软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等，实际上，在软件开发生命周期的每一个阶段都存在着一些被认同的模式。

软件模式是在软件开发过程中某些可重现问题的一些有效解决方法，软件模式的基础结构主要由四部分组成，包括问题描述（待解决的问题是什么）、前提条件（在何种环境或约束条件下使用）、解法（如何解决）和效果（有哪些优缺点）。

![](http://img.my.csdn.net/uploads/201204/02/1333301568_8769.gif)

设计模式用于在特定条件下为一些重复出现的软件设计问题提供合理的、有效的解决方案。

## 设计模式是什么

设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码的可靠性。

设计模式一般包含模式名称、问题、目的、解决方案、效果等组成要素，其中关键要素是模式名称、问题、解决方案和效果。

模式名称（Pattern Name）通过一两个词来描述模式的问题、解决方案和效果，以便更好的理解模式并方便开发人员之间的交流，绝大多模式都是根据其功能或模式结构来命名的。

问题描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因。

解决方案描述了一个设计模式的组成成分，以及这些组成成分之间的相互关系，各自的职责和协作方式，通常解决方案通过UML类图和核心代码进行描述。

效果描述了模式的优缺点以及在使用模式时应权衡的问题。

根据用途，设计模式可以分为创建型、结构型和行为型三种。创建型模式主要用于描述如何创建对象；结构型模式主要用于描述如何实现类或对象的组合；行为型模式主要用于描述类或对象怎样交互以及怎样分配职责。

设计模式一览表：

| 类型 | 模式名称 | 学习难度 | 使用频率 |
| :--- | :--- | :--- | :--- |
| 创建型模式 | 单例模式 | 1 | 4 |
|  | 简单工厂模式 | 2 | 3 |
|  | 工厂方法模式 | 2 | 5 |
|  | 抽象工厂模式 | 4 | 5 |
|  | 原型模式 | 3 | 3 |
|  | 建造者模式 | 4 | 2 |
| 结构型模式 | 适配器模式 | 2 | 4 |
|  | 桥接模式 | 2 | 4 |
|  | 组合模式 | 3 | 4 |
|  | 装饰模式 | 3 | 3 |
|  | 外观模式 | 1 | 5 |
|  | 享元模式 | 4 | 1 |
|  | 代理模式 | 3 | 4 |
| 行为型模式 | 职责链模式 | 3 | 2 |
|  | 命令模式 | 3 | 4 |
|  | 解释器模式 | 5 | 1 |
|  | 迭代模式 | 3 | 5 |
|  | 中介者模式 | 3 | 2 |
|  | 备忘录模式 | 2 | 2 |
|  | 观察者模式 | 3 | 5 |
|  | 状态模式 | 3 | 3 |
|  | 策略模式 | 1 | 4 |
|  | 模板方法模式 | 2 | 3 |
|  | 访问者模式 | 4 | 1 |

## 设计模式到底有什么用

1. 设计模式来源众多专家的经验和智慧，他们是从许多优秀的软件系统中总结出的成功的、能够实现可维护性复用的设计方案，使用这些方案可以让我们避免做一些重复性的工作，也许我们冥思苦想得到的一个”自以为很了不起“的设计方案其实就是某一个设计模式。时间就是金钱的今天，设计模式无疑会有助于提高开发和设计效率。但它不保证一定会提高。
2. 设计模式提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间沟通和交流，使得设计方案更加通俗易懂。
3. 大部分的设计模式都兼顾了系统的可重用性和可扩展性，这使得我们可以更好地重用一些已有的设计方案、功能模块甚至一个完整的软件系统，避免我们经常做一些重复的设计、编写一些重复的代码。
4. 合理的是使用设计模式并对设计模式的使用情况进行文档化，将有助于别人更快的理解系统。
5. 学些设计模式有助于初学者更加深入地理解面向对象思想。

## 面向对象设计原则

单一职责原则：一个类只负责一个功能领域的相应职责

开闭原则：软件实体应该对扩展开放，而对修改关闭

里氏替换原则：所有引用基类对象的地方能够透明地使用其子类的对象

依赖倒转原则：抽象不应该依赖于细节，细节应该依赖于抽象。

接口隔离原则：使用多个专用的接口，而不使用单一的总接口。

合成复用原则：尽量使用对象组合，而不是继承来达到复用的目的。

迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用。

## 工厂模式

在所有的工厂模式中，我们都强调一点：两个类A和B之间的关系应该仅仅是A创建B或者A使用B，而不能两种关系都有。

将对象的创建和使用分离，使得系统更加符合“单一职责原则”，有利于对功能的复用和系统的维护。此外，将对象的创建和使用分离还有一个好处：防止用来实例化一个类的数据和代码在多个类中到处都是，可以将有关创建的知识搬移到一个工厂类中。

### 简单工厂模式

简单工厂模式（Simple Factory Pattern） 基本流程如下：首先将需要创建的各种不同对象的相关代码封装到不同的类中，这些类称之为具体产品类，而将它们公共的代码进行抽象后提取后封装一个抽象产品类中，每一个具体产品类都是抽象产品类的子类；然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象，客户端只需要调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。

简单工厂模式：定义一个工厂类，他可以根据参数的不同返回具体的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建的实例的方法是镜头方法，因此简单工厂模式又被称为静态工厂方法模式，他属于类的创建型模式。

简单模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建的细节。



工厂角色：工厂角色是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法，它的返回类型为抽象产品类型。

抽象产品角色：抽象产品角色是工厂类所创建的所有对象的父类，封装了各种产品对象的公用方法，它的引入将提高系统的灵活性，使得在工厂类中只需要定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。

具体产品角色：具体产品角色是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的摸个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。



在使用简单工厂模式时，首先需要对产品类进行重构，不能设计一个包罗万象的产品类，而需要根据实际情况设计一个产品层次结构，将所有产品类公共的代码移动到抽象产品类，并在抽象产品类中声明一些抽象方法，以供不同的具体产品实现。

在具体的产品类中实现了抽象产品类中声明的抽象业务方法，不同的具体产品类可以提供不同的实现。

简单工厂模式的核心是工厂类，在没有工厂类之前，客户端一般会使用new关键字来直接创建产品对象，在引入工厂类之后，客户端可以通过工厂类来创建产品，在简单工厂模式中，工厂类提供了一个静态方法供客户端使用，根据所传入的参数不同可以创建不同的产品对象。

有时候，为了简化简单工厂模式，我们可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品中。

### 简单工厂模式总结

简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开，它作为一种最简单的工厂模式在软件开发中得到了较为广泛的应用。

#### 简单工厂模式主要优点

工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。

客户端无需知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。

通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。

#### 简单工厂模式的主要缺点

由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。

使用简单工厂模式势必会增加系统中类的个数，增加了系统的复杂度和理解难度。

系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能会造成工厂逻辑的过于复杂，不利于系统的扩展和维护。

简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。

#### 简单工厂模式的适用场景

工厂类负责创建的对象比较少，由于创建的对象比较少，不会造成工厂方法中的业务逻辑太过复杂。

客户端只知道传入工厂类的参数，对于如何创建对象并不关系。

> 练习：
>
> 使用简单工厂模式设计一个可以创建不同几何形状（如圆形、方形、和三角形）的绘图工具，每个几何图形都具有绘制draw\(\)和擦除erase\(\)两个方法，要求在绘制不支持的几何图形时，提示一个UnSupportedShapeException。











