

## 工厂模式

在所有的工厂模式中，我们都强调一点：两个类A和B之间的关系应该仅仅是A创建B或者A使用B，而不能两种关系都有。

将对象的创建和使用分离，使得系统更加符合“单一职责原则”，有利于对功能的复用和系统的维护。此外，将对象的创建和使用分离还有一个好处：防止用来实例化一个类的数据和代码在多个类中到处都是，可以将有关创建的知识搬移到一个工厂类中。

### 简单工厂模式

简单工厂模式（Simple Factory Pattern） 基本流程如下：首先将需要创建的各种不同对象的相关代码封装到不同的类中，这些类称之为具体产品类，而将它们公共的代码进行抽象后提取后封装一个抽象产品类中，每一个具体产品类都是抽象产品类的子类；然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象，客户端只需要调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。

简单工厂模式：定义一个工厂类，他可以根据参数的不同返回具体的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建的实例的方法是镜头方法，因此简单工厂模式又被称为静态工厂方法模式，他属于类的创建型模式。

简单模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建的细节。



工厂角色：工厂角色是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法，它的返回类型为抽象产品类型。

抽象产品角色：抽象产品角色是工厂类所创建的所有对象的父类，封装了各种产品对象的公用方法，它的引入将提高系统的灵活性，使得在工厂类中只需要定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。

具体产品角色：具体产品角色是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的摸个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。



在使用简单工厂模式时，首先需要对产品类进行重构，不能设计一个包罗万象的产品类，而需要根据实际情况设计一个产品层次结构，将所有产品类公共的代码移动到抽象产品类，并在抽象产品类中声明一些抽象方法，以供不同的具体产品实现。

在具体的产品类中实现了抽象产品类中声明的抽象业务方法，不同的具体产品类可以提供不同的实现。

简单工厂模式的核心是工厂类，在没有工厂类之前，客户端一般会使用new关键字来直接创建产品对象，在引入工厂类之后，客户端可以通过工厂类来创建产品，在简单工厂模式中，工厂类提供了一个静态方法供客户端使用，根据所传入的参数不同可以创建不同的产品对象。

有时候，为了简化简单工厂模式，我们可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品中。

### 简单工厂模式总结

简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开，它作为一种最简单的工厂模式在软件开发中得到了较为广泛的应用。

#### 简单工厂模式主要优点

工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。

客户端无需知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。

通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。

#### 简单工厂模式的主要缺点

由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。

使用简单工厂模式势必会增加系统中类的个数，增加了系统的复杂度和理解难度。

系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能会造成工厂逻辑的过于复杂，不利于系统的扩展和维护。

简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。

#### 简单工厂模式的适用场景

工厂类负责创建的对象比较少，由于创建的对象比较少，不会造成工厂方法中的业务逻辑太过复杂。

客户端只知道传入工厂类的参数，对于如何创建对象并不关系。

> 练习：
>
> 使用简单工厂模式设计一个可以创建不同几何形状（如圆形、方形、和三角形）的绘图工具，每个几何图形都具有绘制draw\(\)和擦除erase\(\)两个方法，要求在绘制不支持的几何图形时，提示一个UnSupportedShapeException。











